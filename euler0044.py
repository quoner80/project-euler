# Pentagon numbers
#
# Pentagonal numbers are generated by the formula, P_n = n(3n - 1)/2. The first ten pentagonal numbers are:
#   1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
#
# It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 - 22 = 48, is not pentagonal.
#
# Find the pair of pentagonal numbers, P_j and P_k, for which their sum and difference are pentagonal and D = |P_k - P_j| is minimised; what is the value of D?

import math;
import sys;
import time;

start_time = time.time();

def p_n(n):
    return n * ((3 * n) - 1) / 2;

def n_p(p):
    n = int((1 + round(math.sqrt(1 + 24 * p))) / 6);
    if p == p_n(n):
        return n;
    else:
        return None;

# The first element in next_at_gap represents the 1-unit gap, the second represents the 2-unit gap, and so on, so the i-th
# element represents thr (i-1)-unit gap (due to 0-based indexing). Each value indicates how far the algorithm has checked for
# at that gap. For example [10, 5, 1] means the next 1-unit gap to be checked would be p(11) - p(10) (the algorithm has already
# checked p(10) - p(9), the next 2-unit gap to be checked would be p(7) - p(5) (the algorithm has already checked p(6) - p(4),
# and the next 3-unit gap to be checked would be p(4) - p(1) (the algorithm has not yet checked any 3-unit gap).
next_at_gap = [1];

while True:
    d_min = sys.maxint;
    d_min_i = 0
    d_min_n_j = 0;
    d_min_n_k = 0;
    d_min_p_n_j = 0;
    d_min_p_n_k = 0;
    length = len(next_at_gap);
    for i in range(length):
        n_j = next_at_gap[i];
        p_n_j = p_n(n_j);
        n_k = n_j + i + 1;
        p_n_k = p_n(n_k);
        d = p_n_k - p_n_j;
        if d < d_min:
            d_min = d;
            d_min_i = i;
            d_min_n_j = n_j;
            d_min_n_k = n_k;
            d_min_p_n_j = p_n_j;
            d_min_p_n_k = p_n_k;
    next_at_gap[d_min_i] += 1;
    if (d_min_n_j == 1) and (i == length - 1):
        # If the final element in the array has been changed from 1 to 2, add another gap value, starting at 1.
        next_at_gap.append(1);
    if n_p(d_min) != None:
        print d_min, d_min_n_j, d_min_n_k, d_min_i, length;
        d_min_sum = d_min_p_n_j + d_min_p_n_k;
        if n_p(d_min_sum) != None:
            print d_min_sum;
            print "found it!";
            break;

print "Execution time = %f seconds." % (time.time() - start_time);
