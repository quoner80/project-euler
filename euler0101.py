# Optimum polynomial
# Problem 101
#
# If we are presented with the first k terms of a sequence it is impossible to say with certainty the value of the next term, as there are infinitely many polynomial functions that can model the sequence.
#
# As an example, let us consider the sequence of cube numbers. This is defined by the generating function, 
#   u_n = n^3: 1, 8, 27, 64, 125, 216, ...
#
# Suppose we were only given the first two terms of this sequence. Working on the principle that "simple is best" we should assume a linear relationship and predict the next term to be 15 (common difference 7). Even if we were presented with the first three terms, by the same principle of simplicity, a quadratic relationship should be assumed.
#
# We shall define OP(k, n) to be the nth term of the optimum polynomial generating function for the first k terms of a sequence. It should be clear that OP(k, n) will accurately generate the terms of the sequence for n <= k, and potentially the first incorrect term (FIT) will be OP(k, k + 1); in which case we shall call it a bad OP (BOP).
#
# As a basis, if we were only given the first term of sequence, it would be most sensible to assume constancy; that is, for n >= 2, OP(1, n) = u_1.
#
# Hence we obtain the following OPs for the cubic sequence:
#
#   OP(1, n) = 1                1, _1_, 1, 1, ...
#   OP(2, n) = 7n - 6           1, 8, _15_, ...
#   OP(3, n) = 6n^2 - 11n + 6   1, 8, 27, _58_, ...
#   OP(4, n) = n^3              1, 8, 27, 64, 125, ...
#
# Clearly no BOPs exist for k >= 4.
#
# By considering the sum of FITs generated by the BOPs (indicated in _red_ above), we obtain 1 + 15 + 58 = 74.
#
# Consider the following tenth degree polynomial generating function:
#
#   u_n = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^10
#
# Find the sum of FITs for the BOPs.

import numpy;
import time;

start_time = time.time();

def print_execution_time():
    print "Execution time = %f seconds." % (time.time() - start_time);

D = 10;

u = [];
for n in range(1, D + 3):
    u.append(1 - n + (n ** 2) - (n ** 3) + (n ** 4) - (n ** 5) + (n ** 6) - (n ** 7) + (n ** 8) - (n ** 9) + (n ** 10));
    print "u[%d] = %d." % (n - 1, u[n - 1]);
print;

# Individual examples.
"""
A = numpy.matrix([[1, 1], [1, 2]]);
b = numpy.matrix([[1], [683]]);
print numpy.linalg.solve(A, b);

A = numpy.matrix([[1, 1, 1], [1, 2, 4], [1, 3, 9]]);
b = numpy.matrix([[1], [683], [44287]]);
print numpy.linalg.solve(A, b);
"""

FIT_SUM = 0;

for d in range(1, D + 1):
    A_rows = [];
    b_rows = [];
    for r in range(d):
        A_rows.append([]);
        for exponent in range(d):
            A_rows[r].append((r + 1) ** exponent);
        b_rows.append([u[r]]);
    A = numpy.matrix(A_rows);
    b = numpy.matrix(b_rows);
    x = numpy.linalg.solve(A, b);
    coefficients = x.transpose().tolist()[0];
    # print x;
    # print coefficients;

    for n in range(1, d + 2):
        OP_d_n = 0;
        for i in range(d):
            OP_d_n += coefficients[i] * (n ** i);
        OP_d_n_rounded = int(round(OP_d_n));
        print "OP(%d, %d) ~ %f -> %d." % (d, n, OP_d_n, OP_d_n_rounded);
        if OP_d_n_rounded != u[n - 1]:
            print "FIT(%d) = %d." % (d, OP_d_n_rounded);
            FIT_SUM += OP_d_n_rounded;
            break;
    print;

print "Sum of FITs = %d" % FIT_SUM;
print_execution_time();
